local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local CurrentTarget
local FovCircle = Drawing.new("Circle")
FovCircle.Position = UserInputService:GetMouseLocation()
FovCircle.Radius = 300
FovCircle.Visible = true
FovCircle.Color = Color3.fromRGB(255, 0, 0)
local Line = Drawing.new("Line")
Line.Color = Color3.fromRGB(255, 0, 0)
local FighterController = require(LocalPlayer.PlayerScripts.Controllers.FighterController)
local LocalFighter = FighterController.LocalFighter
local Old = LocalFighter.GetMouseLocation
LocalFighter.GetMouseLocation = newcclosure(function(...)
    if CurrentTarget then
        local ScreenPosition = Camera:WorldToScreenPoint(CurrentTarget.Position)
        return Vector2.new(ScreenPosition.X,ScreenPosition.Y)
    end
    return Old(...)
end)
RunService.RenderStepped:Connect(function()
    FovCircle.Position = UserInputService:GetMouseLocation()
    local PlayerCharacter = LocalPlayer.Character
    if not PlayerCharacter then
        CurrentTarget = nil
        return
    end
    local CharacterRoot = PlayerCharacter:FindFirstChild("HumanoidRootPart")
    if not CharacterRoot then
        CurrentTarget = nil
        return
    end
    local CameraPosition = Camera.CFrame.Position
    local CameraLookVector = Camera.CFrame.LookVector
    CurrentTarget = nil
    local ClosestDistance = math.huge
    for _, OtherPlayer in Players:GetPlayers() do
        if OtherPlayer == LocalPlayer then
            continue
        end
        local TargetCharacter = OtherPlayer.Character
        if not TargetCharacter then
            continue
        end
        local TargetHumanoid = TargetCharacter:FindFirstChildOfClass("Humanoid")
        if not TargetHumanoid or TargetHumanoid.Health <= 0 then
            continue
        end
        if TargetCharacter:FindFirstChildOfClass("ForceField") then
            continue
        end
        local TargetHead = TargetCharacter:FindFirstChild("Head")
        if not TargetHead then
            continue
        end
        local HeadPosition = TargetHead.Position
        local ScreenPosition, IsOnScreen = Camera:WorldToViewportPoint(HeadPosition)
        if IsOnScreen then
            local ScreenVector = Vector2.new(ScreenPosition.X, ScreenPosition.Y)
            local DistanceFromCenter = (ScreenVector - UserInputService:GetMouseLocation()).Magnitude
            if DistanceFromCenter <= FovCircle.Radius and DistanceFromCenter < ClosestDistance then
                local DirectionToTarget = (HeadPosition - CameraPosition).Unit
                local DotProduct = CameraLookVector:Dot(DirectionToTarget)
                if DotProduct > 0 then
                    local WallCheckRay = Ray.new(CameraPosition, HeadPosition - CameraPosition)
                    local RayHit = workspace:FindPartOnRayWithIgnoreList(WallCheckRay, {
                        PlayerCharacter
                    })
                    local IsVisible = false
                    if RayHit then
                        if RayHit.Parent == TargetCharacter or RayHit.Parent.Parent == TargetCharacter then
                            IsVisible = true
                        end
                    else
                        IsVisible = true
                    end
                    if IsVisible then
                        ClosestDistance = DistanceFromCenter
                        CurrentTarget = TargetHead
                    end
                end
            end
        end
    end
    if CurrentTarget then
        local ScreenPosition, IsOnScreen = Camera:WorldToViewportPoint(CurrentTarget.Position)
        if IsOnScreen then
            local ScreenVector = Vector2.new(ScreenPosition.X, ScreenPosition.Y)
            Line.Visible = true
            Line.From = UserInputService:GetMouseLocation()
            Line.To = ScreenVector
        else
            Line.Visible = false
        end
    else
        Line.Visible = false
    end
end)
